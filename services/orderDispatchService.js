/**
 * Order Dispatch Service
 * Business logic for order management
 */

const db = require('../config/db');
const OrderDispatch = require('../models/orderDispatchModel');
const { Logger } = require('../utils');

class OrderDispatchService {
  /**
   * Create order(s) - handles single or multiple products
   * Order number is now auto-generated by database trigger
   * @param {Object} orderData - Order data from form
   * @param {Array} products - Array of products (if multiple)
   * @returns {Promise<Object>} Created orders with generated order_no
   */
  async createOrder(orderData, products = []) {
    const client = await db.getClient();
    
    try {
      await client.query('BEGIN');
      
      const createdOrders = [];
      
      // If multiple products
      if (products && products.length > 0) {
        for (let i = 0; i < products.length; i++) {
          const product = products[i];
          
          Logger.info(`[DEBUG-TRACKING] Creating multi-product order. Raw data:`, { 
            customer_name: orderData.customer_name,
            username: orderData.username 
          });

          const orderRow = new OrderDispatch({
            ...orderData,
            // order_no will be auto-generated by database trigger
            product_name: product.product_name,
            uom: product.uom,
            order_quantity: product.order_quantity,
            rate_of_material: product.rate_of_material,
            alternate_uom: product.alternate_uom,
            alternate_qty_kg: product.alternate_qty_kg,
            oil_type: product.oil_type,
            rate_per_15kg: product.rate_per_15kg,
            rate_per_ltr: product.rate_per_ltr,
            sku_name: product.sku_name,
            approval_qty: product.approval_qty,
            // For regular orders, set remaining_dispatch_qty to order_quantity immediately
            remaining_dispatch_qty: orderData.order_type === 'regular' ? product.order_quantity : null,
            order_punch_user: orderData.username || null
          });

          Logger.info(`[DEBUG-TRACKING] Prepared OrderDispatch row (Multi):`, { 
            order_punch_user: orderRow.order_punch_user
          });
          
          const inserted = await this.insertOrder(client, orderRow);
          createdOrders.push(inserted);
        }
      } else {
        // Single product
        Logger.info(`[DEBUG-TRACKING] Creating single-product order. Raw data:`, { 
          customer_name: orderData.customer_name,
          username: orderData.username 
        });

        const orderRow = new OrderDispatch({
          ...orderData,
          order_punch_user: orderData.username || null
          // order_no will be auto-generated by database trigger
        });

        Logger.info(`[DEBUG-TRACKING] Prepared OrderDispatch row (Single):`, { 
          order_punch_user: orderRow.order_punch_user
        });
        
        const inserted = await this.insertOrder(client, orderRow);
        createdOrders.push(inserted);
      }
      
      await client.query('COMMIT');
      
      // Extract the generated order number (without serial letter for display)
      const generatedOrderNo = createdOrders[0].order_no;
      
      Logger.info(`Orders created successfully with order number: ${generatedOrderNo}`);
      
      return {
        success: true,
        message: 'Order created successfully',
        data: {
          order_no: generatedOrderNo,
          orders: createdOrders
        }
      };
    } catch (error) {
      await client.query('ROLLBACK');
      Logger.error('Error creating order', error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Insert single order into database
   * @param {Object} client - Database client
   * @param {OrderDispatch} order - Order object
   * @returns {Promise<Object>} Inserted order
   */
  async insertOrder(client, order) {
    const data = order.toDatabase();
    
    const fields = Object.keys(data);
    const values = Object.values(data);
    const placeholders = fields.map((_, index) => `$${index + 1}`);
    
    const query = `
      INSERT INTO order_dispatch (${fields.join(', ')})
      VALUES (${placeholders.join(', ')})
      RETURNING *
    `;
    
    const result = await client.query(query, values);
    return result.rows[0];
  }

  /**
   * Get all orders with pagination
   * @param {Object} filters - Filter parameters
   * @param {Object} pagination - Pagination parameters
   * @returns {Promise<Object>} Orders list
   */
  async getAllOrders(filters = {}, pagination = {}) {
    try {
      const page = parseInt(pagination.page) || 1;
      const limit = parseInt(pagination.limit) || 10;
      const offset = (page - 1) * limit;
      
      let whereConditions = [];
      let queryParams = [];
      let paramIndex = 1;
      
      // Add filters
      if (filters.order_no) {
        whereConditions.push(`order_no = $${paramIndex}`);
        queryParams.push(filters.order_no);
        paramIndex++;
      }
      
      if (filters.customer_name) {
        whereConditions.push(`customer_name ILIKE $${paramIndex}`);
        queryParams.push(`%${filters.customer_name}%`);
        paramIndex++;
      }
      
      if (filters.order_type) {
        whereConditions.push(`order_type = $${paramIndex}`);
        queryParams.push(filters.order_type);
        paramIndex++;
      }
      
      const whereClause = whereConditions.length > 0 
        ? `WHERE ${whereConditions.join(' AND ')}` 
        : '';
      
      // Count total records
      const countQuery = `SELECT COUNT(*) FROM order_dispatch ${whereClause}`;
      const countResult = await db.query(countQuery, queryParams);
      const total = parseInt(countResult.rows[0].count);
      
      // Get paginated data
      const dataQuery = `
        SELECT * FROM order_dispatch 
        ${whereClause}
        ORDER BY created_at DESC, order_no ASC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;
      
      const dataResult = await db.query(dataQuery, [...queryParams, limit, offset]);
      
      return {
        success: true,
        data: dataResult.rows,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      Logger.error('Error fetching orders', error);
      throw new Error('Failed to fetch orders');
    }
  }

  /**
   * Get order by order number
   * @param {string} orderNo - Order number
   * @returns {Promise<Object>} Order details
   */
  async getOrderByNumber(orderNo) {
    try {
      const query = `
        SELECT * FROM order_dispatch 
        WHERE order_no = $1
        ORDER BY order_no ASC
      `;
      
      const result = await db.query(query, [orderNo]);
      
      if (result.rows.length === 0) {
        throw new Error('Order not found');
      }
      
      return {
        success: true,
        data: result.rows
      };
    } catch (error) {
      Logger.error('Error fetching order', error);
      throw error;
    }
  }

  /**
   * Update order
   * @param {number} id - Order ID
   * @param {Object} updateData - Data to update
   * @returns {Promise<Object>} Updated order
   */
  async updateOrder(id, updateData) {
    try {
      const fields = Object.keys(updateData);
      const values = Object.values(updateData);
      
      const setClause = fields.map((field, index) => `${field} = $${index + 1}`).join(', ');
      
      const query = `
        UPDATE order_dispatch 
        SET ${setClause}
        WHERE id = $${fields.length + 1}
        RETURNING *
      `;
      
      const result = await db.query(query, [...values, id]);
      
      if (result.rows.length === 0) {
        throw new Error('Order not found');
      }
      
      return {
        success: true,
        message: 'Order updated successfully',
        data: result.rows[0]
      };
    } catch (error) {
      Logger.error('Error updating order', error);
      throw error;
    }
  }

  /**
   * Delete order
   * @param {number} id - Order ID
   * @returns {Promise<Object>} Delete confirmation
   */
  async deleteOrder(id) {
    try {
      const query = `DELETE FROM order_dispatch WHERE id = $1 RETURNING *`;
      const result = await db.query(query, [id]);
      
      if (result.rows.length === 0) {
        throw new Error('Order not found');
      }
      
      return {
        success: true,
        message: 'Order deleted successfully'
      };
    } catch (error) {
      Logger.error('Error deleting order', error);
      throw error;
    }
  }

  /**
   * Get pending pre-approval orders
   * Pending: planned_1 IS NOT NULL AND actual_1 IS NULL
   * @param {Object} filters - Filter parameters
   * @param {Object} pagination - Pagination parameters
   * @returns {Promise<Object>} Pending orders
   */
  async getPendingPreApprovals(filters = {}, pagination = {}) {
    try {
      const page = parseInt(pagination.page) || 1;
      const limit = parseInt(pagination.limit) || 10;
      const offset = (page - 1) * limit;
      
      let whereConditions = ['planned_1 IS NOT NULL', 'actual_1 IS NULL'];
      let queryParams = [];
      let paramIndex = 1;
      
      // Add optional filters
      if (filters.order_no) {
        whereConditions.push(`order_no = $${paramIndex}`);
        queryParams.push(filters.order_no);
        paramIndex++;
      }
      
      if (filters.customer_name) {
        whereConditions.push(`customer_name ILIKE $${paramIndex}`);
        queryParams.push(`%${filters.customer_name}%`);
        paramIndex++;
      }
      
      if (filters.start_date && filters.end_date) {
        whereConditions.push(`delivery_date BETWEEN $${paramIndex} AND $${paramIndex + 1}`);
        queryParams.push(filters.start_date, filters.end_date);
        paramIndex += 2;
      }
      
      const whereClause = `WHERE ${whereConditions.join(' AND ')}`;
      
      // Count total
      const countQuery = `SELECT COUNT(*) FROM order_dispatch ${whereClause}`;
      const countResult = await db.query(countQuery, queryParams);
      const total = parseInt(countResult.rows[0].count);
      
      // Get data
      const dataQuery = `
        SELECT * FROM order_dispatch 
        ${whereClause}
        ORDER BY created_at DESC, order_no ASC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;
      
      const dataResult = await db.query(dataQuery, [...queryParams, limit, offset]);
      
      return {
        success: true,
        data: dataResult.rows,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      Logger.error('Error fetching pending pre-approvals', error);
      throw new Error('Failed to fetch pending pre-approvals');
    }
  }

  /**
   * Get pre-approval history
   * History: planned_1 IS NOT NULL AND actual_1 IS NOT NULL
   * @param {Object} filters - Filter parameters
   * @param {Object} pagination - Pagination parameters
   * @returns {Promise<Object>} History orders
   */
  async getPreApprovalHistory(filters = {}, pagination = {}) {
    try {
      const page = parseInt(pagination.page) || 1;
      const limit = parseInt(pagination.limit) || 10;
      const offset = (page - 1) * limit;
      
      let whereConditions = ['planned_1 IS NOT NULL', 'actual_1 IS NOT NULL'];
      let queryParams = [];
      let paramIndex = 1;
      
      // Add optional filters
      if (filters.order_no) {
        whereConditions.push(`order_no = $${paramIndex}`);
        queryParams.push(filters.order_no);
        paramIndex++;
      }
      
      if (filters.customer_name) {
        whereConditions.push(`customer_name ILIKE $${paramIndex}`);
        queryParams.push(`%${filters.customer_name}%`);
        paramIndex++;
      }
      
      if (filters.start_date && filters.end_date) {
        whereConditions.push(`delivery_date BETWEEN $${paramIndex} AND $${paramIndex + 1}`);
        queryParams.push(filters.start_date, filters.end_date);
        paramIndex += 2;
      }
      
      const whereClause = `WHERE ${whereConditions.join(' AND ')}`;
      
      // Count total
      const countQuery = `SELECT COUNT(*) FROM order_dispatch ${whereClause}`;
      const countResult = await db.query(countQuery, queryParams);
      const total = parseInt(countResult.rows[0].count);
      
      // Get data
      const dataQuery = `
        SELECT * FROM order_dispatch 
        ${whereClause}
        ORDER BY actual_1 DESC, order_no ASC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;
      
      const dataResult = await db.query(dataQuery, [...queryParams, limit, offset]);
      
      return {
        success: true,
        data: dataResult.rows,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      Logger.error('Error fetching pre-approval history', error);
      throw new Error('Failed to fetch pre-approval history');
    }
  }

  /**
   * Submit pre-approval (set actual_1 to current timestamp)
   * Supports partial approvals - if approval_qty < order_quantity, creates new row with remaining qty
   * @param {number} id - Order ID
   * @param {Object} data - Optional additional data to update
   * @returns {Promise<Object>} Updated order
   */
  async submitPreApproval(id, data = {}) {
    const client = await db.getClient();
    
    try {
      await client.query('BEGIN');
      
      // Step 1: Get original order data
      const originalQuery = 'SELECT * FROM order_dispatch WHERE id = $1';
      const originalResult = await client.query(originalQuery, [id]);
      
      if (originalResult.rows.length === 0) {
        throw new Error('Order not found');
      }
      
      const originalOrder = originalResult.rows[0];
      const approvalQty = parseFloat(data.approval_qty) || 0;
      const orderQty = parseFloat(originalOrder.order_quantity) || 0;
      
      // Step 2: Update the approved order
      const updateData = {
        actual_1: new Date().toISOString(),
        pre_approval_user: data.username || null,
        ...data
      };
      
      // Remove username from data if it exists to avoid trying to update a non-existent column in the spread (...data)
      if (updateData.username) delete updateData.username;
      
      const fields = Object.keys(updateData);
      const values = Object.values(updateData);
      const setClause = fields.map((field, index) => `${field} = $${index + 1}`).join(', ');
      
      const updateQuery = `
        UPDATE order_dispatch 
        SET ${setClause}
        WHERE id = $${fields.length + 1}
        RETURNING *
      `;
      
      const updateResult = await client.query(updateQuery, [...values, id]);
      
      // Step 3: Check for partial approval and create remaining qty row
      const updatedOrder = updateResult.rows[0];
      const updatedOrderQty = parseFloat(updatedOrder.order_quantity) || 0;

      let remainingOrder = null;
      if (approvalQty > 0 && approvalQty < updatedOrderQty) {
        const remainingQty = updatedOrderQty - approvalQty;
        
        Logger.info(`Partial approval detected. Creating new row for remaining qty: ${remainingQty}`);
        
        // Generate new order number with -1 suffix (e.g., DO-106A-1)
        const newOrderNo = `${originalOrder.order_no}-1`;
        
        // Create new order row with remaining quantity
        const remainingOrderData = new OrderDispatch({
          // Manually set order number
          order_no: newOrderNo,
          
          // Copy all original order data
          customer_name: originalOrder.customer_name,
          customer_type: originalOrder.customer_type,
          order_type: originalOrder.order_type,
          order_type_delivery_purpose: originalOrder.order_type_delivery_purpose,
          start_date: originalOrder.start_date,
          end_date: originalOrder.end_date,
          delivery_date: originalOrder.delivery_date,
          party_so_date: originalOrder.party_so_date,
          customer_contact_person_name: originalOrder.customer_contact_person_name,
          customer_contact_person_whatsapp_no: originalOrder.customer_contact_person_whatsapp_no,
          customer_address: originalOrder.customer_address,
          payment_terms: originalOrder.payment_terms,
          advance_payment_to_be_taken: originalOrder.advance_payment_to_be_taken,
          advance_amount: originalOrder.advance_amount,
          is_order_through_broker: originalOrder.is_order_through_broker,
          broker_name: originalOrder.broker_name,
          type_of_transporting: originalOrder.type_of_transporting,
          depo_name: originalOrder.depo_name,
          order_punch_remarks: originalOrder.order_punch_remarks,
          total_amount_with_gst: originalOrder.total_amount_with_gst,
          item_confirm_by_manager: originalOrder.item_confirm_by_manager,
          
          // Product details
          product_name: originalOrder.product_name,
          oil_type: originalOrder.oil_type,
          uom: originalOrder.uom,
          alternate_uom: originalOrder.alternate_uom,
          alternate_qty_kg: originalOrder.alternate_qty_kg,
          rate_per_15kg: originalOrder.rate_per_15kg,
          rate_per_ltr: originalOrder.rate_per_ltr,
          rate_of_material: originalOrder.rate_of_material,
          
          // Set remaining quantity
          order_quantity: remainingQty,
          
          // Reset approval fields (this row needs new approval)
          approval_qty: null,
          remaining_dispatch_qty: null,
          sku_name: null,
          final_rate: null,
          remark: null,
          
          // Set workflow status - keep in pre-approval
          planned_1: new Date().toISOString(),
          actual_1: null // Not approved yet
        });
        
        remainingOrder = await this.insertOrder(client, remainingOrderData);
        
        Logger.info(`Created remaining order with ID: ${remainingOrder.id}, order_no: ${remainingOrder.order_no}`);
      }
      
      await client.query('COMMIT');
      
      Logger.info(`Pre-approval submitted for order ID: ${id}`);
      
      return {
        success: true,
        message: remainingOrder 
          ? `Pre-approval submitted. Remaining quantity (${remainingOrder.order_quantity}) added to pending.`
          : 'Pre-approval submitted successfully',
        data: {
          approved: updateResult.rows[0],
          remaining: remainingOrder
        }
      };
    } catch (error) {
      await client.query('ROLLBACK');
      Logger.error('Error submitting pre-approval', error);
      throw error;
    } finally {
      client.release();
    }
  }
}

module.exports = new OrderDispatchService();
