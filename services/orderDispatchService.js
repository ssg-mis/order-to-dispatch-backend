/**
 * Order Dispatch Service
 * Business logic for order management
 */

const db = require('../config/db');
const OrderDispatch = require('../models/orderDispatchModel');
const { Logger } = require('../utils');

class OrderDispatchService {
  /**
   * Create order(s) - handles single or multiple products
   * Order number is now auto-generated by database trigger
   * @param {Object} orderData - Order data from form
   * @param {Array} products - Array of products (if multiple)
   * @returns {Promise<Object>} Created orders with generated order_no
   */
  async createOrder(orderData, products = []) {
    const client = await db.getClient();
    
    try {
      await client.query('BEGIN');
      
      const createdOrders = [];
      
      // If multiple products
      if (products && products.length > 0) {
        for (let i = 0; i < products.length; i++) {
          const product = products[i];
          
          const orderRow = new OrderDispatch({
            ...orderData,
            // order_no will be auto-generated by database trigger
            product_name: product.product_name,
            uom: product.uom,
            order_quantity: product.order_quantity,
            rate_of_material: product.rate_of_material,
            alternate_uom: product.alternate_uom,
            alternate_qty_kg: product.alternate_qty_kg,
            oil_type: product.oil_type,
            rate_per_15kg: product.rate_per_15kg,
            rate_per_ltr: product.rate_per_ltr,
            sku_name: product.sku_name,
            approval_qty: product.approval_qty
          });
          
          const inserted = await this.insertOrder(client, orderRow);
          createdOrders.push(inserted);
        }
      } else {
        // Single product
        const orderRow = new OrderDispatch({
          ...orderData
          // order_no will be auto-generated by database trigger
        });
        
        const inserted = await this.insertOrder(client, orderRow);
        createdOrders.push(inserted);
      }
      
      await client.query('COMMIT');
      
      // Extract the generated order number (without serial letter for display)
      const generatedOrderNo = createdOrders[0].order_no;
      
      Logger.info(`Orders created successfully with order number: ${generatedOrderNo}`);
      
      return {
        success: true,
        message: 'Order created successfully',
        data: {
          order_no: generatedOrderNo,
          orders: createdOrders
        }
      };
    } catch (error) {
      await client.query('ROLLBACK');
      Logger.error('Error creating order', error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Insert single order into database
   * @param {Object} client - Database client
   * @param {OrderDispatch} order - Order object
   * @returns {Promise<Object>} Inserted order
   */
  async insertOrder(client, order) {
    const data = order.toDatabase();
    
    const fields = Object.keys(data);
    const values = Object.values(data);
    const placeholders = fields.map((_, index) => `$${index + 1}`);
    
    const query = `
      INSERT INTO order_dispatch (${fields.join(', ')})
      VALUES (${placeholders.join(', ')})
      RETURNING *
    `;
    
    const result = await client.query(query, values);
    return result.rows[0];
  }

  /**
   * Get all orders with pagination
   * @param {Object} filters - Filter parameters
   * @param {Object} pagination - Pagination parameters
   * @returns {Promise<Object>} Orders list
   */
  async getAllOrders(filters = {}, pagination = {}) {
    try {
      const page = parseInt(pagination.page) || 1;
      const limit = parseInt(pagination.limit) || 10;
      const offset = (page - 1) * limit;
      
      let whereConditions = [];
      let queryParams = [];
      let paramIndex = 1;
      
      // Add filters
      if (filters.order_no) {
        whereConditions.push(`order_no = $${paramIndex}`);
        queryParams.push(filters.order_no);
        paramIndex++;
      }
      
      if (filters.customer_name) {
        whereConditions.push(`customer_name ILIKE $${paramIndex}`);
        queryParams.push(`%${filters.customer_name}%`);
        paramIndex++;
      }
      
      if (filters.order_type) {
        whereConditions.push(`order_type = $${paramIndex}`);
        queryParams.push(filters.order_type);
        paramIndex++;
      }
      
      const whereClause = whereConditions.length > 0 
        ? `WHERE ${whereConditions.join(' AND ')}` 
        : '';
      
      // Count total records
      const countQuery = `SELECT COUNT(*) FROM order_dispatch ${whereClause}`;
      const countResult = await db.query(countQuery, queryParams);
      const total = parseInt(countResult.rows[0].count);
      
      // Get paginated data
      const dataQuery = `
        SELECT * FROM order_dispatch 
        ${whereClause}
        ORDER BY created_at DESC, order_no ASC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;
      
      const dataResult = await db.query(dataQuery, [...queryParams, limit, offset]);
      
      return {
        success: true,
        data: dataResult.rows,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      Logger.error('Error fetching orders', error);
      throw new Error('Failed to fetch orders');
    }
  }

  /**
   * Get order by order number
   * @param {string} orderNo - Order number
   * @returns {Promise<Object>} Order details
   */
  async getOrderByNumber(orderNo) {
    try {
      const query = `
        SELECT * FROM order_dispatch 
        WHERE order_no = $1
        ORDER BY order_no ASC
      `;
      
      const result = await db.query(query, [orderNo]);
      
      if (result.rows.length === 0) {
        throw new Error('Order not found');
      }
      
      return {
        success: true,
        data: result.rows
      };
    } catch (error) {
      Logger.error('Error fetching order', error);
      throw error;
    }
  }

  /**
   * Update order
   * @param {number} id - Order ID
   * @param {Object} updateData - Data to update
   * @returns {Promise<Object>} Updated order
   */
  async updateOrder(id, updateData) {
    try {
      const fields = Object.keys(updateData);
      const values = Object.values(updateData);
      
      const setClause = fields.map((field, index) => `${field} = $${index + 1}`).join(', ');
      
      const query = `
        UPDATE order_dispatch 
        SET ${setClause}
        WHERE id = $${fields.length + 1}
        RETURNING *
      `;
      
      const result = await db.query(query, [...values, id]);
      
      if (result.rows.length === 0) {
        throw new Error('Order not found');
      }
      
      return {
        success: true,
        message: 'Order updated successfully',
        data: result.rows[0]
      };
    } catch (error) {
      Logger.error('Error updating order', error);
      throw error;
    }
  }

  /**
   * Delete order
   * @param {number} id - Order ID
   * @returns {Promise<Object>} Delete confirmation
   */
  async deleteOrder(id) {
    try {
      const query = `DELETE FROM order_dispatch WHERE id = $1 RETURNING *`;
      const result = await db.query(query, [id]);
      
      if (result.rows.length === 0) {
        throw new Error('Order not found');
      }
      
      return {
        success: true,
        message: 'Order deleted successfully'
      };
    } catch (error) {
      Logger.error('Error deleting order', error);
      throw error;
    }
  }

  /**
   * Get pending pre-approval orders
   * Pending: planned_1 IS NOT NULL AND actual_1 IS NULL
   * @param {Object} filters - Filter parameters
   * @param {Object} pagination - Pagination parameters
   * @returns {Promise<Object>} Pending orders
   */
  async getPendingPreApprovals(filters = {}, pagination = {}) {
    try {
      const page = parseInt(pagination.page) || 1;
      const limit = parseInt(pagination.limit) || 10;
      const offset = (page - 1) * limit;
      
      let whereConditions = ['planned_1 IS NOT NULL', 'actual_1 IS NULL'];
      let queryParams = [];
      let paramIndex = 1;
      
      // Add optional filters
      if (filters.order_no) {
        whereConditions.push(`order_no = $${paramIndex}`);
        queryParams.push(filters.order_no);
        paramIndex++;
      }
      
      if (filters.customer_name) {
        whereConditions.push(`customer_name ILIKE $${paramIndex}`);
        queryParams.push(`%${filters.customer_name}%`);
        paramIndex++;
      }
      
      if (filters.start_date && filters.end_date) {
        whereConditions.push(`delivery_date BETWEEN $${paramIndex} AND $${paramIndex + 1}`);
        queryParams.push(filters.start_date, filters.end_date);
        paramIndex += 2;
      }
      
      const whereClause = `WHERE ${whereConditions.join(' AND ')}`;
      
      // Count total
      const countQuery = `SELECT COUNT(*) FROM order_dispatch ${whereClause}`;
      const countResult = await db.query(countQuery, queryParams);
      const total = parseInt(countResult.rows[0].count);
      
      // Get data
      const dataQuery = `
        SELECT * FROM order_dispatch 
        ${whereClause}
        ORDER BY created_at DESC, order_no ASC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;
      
      const dataResult = await db.query(dataQuery, [...queryParams, limit, offset]);
      
      return {
        success: true,
        data: dataResult.rows,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      Logger.error('Error fetching pending pre-approvals', error);
      throw new Error('Failed to fetch pending pre-approvals');
    }
  }

  /**
   * Get pre-approval history
   * History: planned_1 IS NOT NULL AND actual_1 IS NOT NULL
   * @param {Object} filters - Filter parameters
   * @param {Object} pagination - Pagination parameters
   * @returns {Promise<Object>} History orders
   */
  async getPreApprovalHistory(filters = {}, pagination = {}) {
    try {
      const page = parseInt(pagination.page) || 1;
      const limit = parseInt(pagination.limit) || 10;
      const offset = (page - 1) * limit;
      
      let whereConditions = ['planned_1 IS NOT NULL', 'actual_1 IS NOT NULL'];
      let queryParams = [];
      let paramIndex = 1;
      
      // Add optional filters
      if (filters.order_no) {
        whereConditions.push(`order_no = $${paramIndex}`);
        queryParams.push(filters.order_no);
        paramIndex++;
      }
      
      if (filters.customer_name) {
        whereConditions.push(`customer_name ILIKE $${paramIndex}`);
        queryParams.push(`%${filters.customer_name}%`);
        paramIndex++;
      }
      
      if (filters.start_date && filters.end_date) {
        whereConditions.push(`delivery_date BETWEEN $${paramIndex} AND $${paramIndex + 1}`);
        queryParams.push(filters.start_date, filters.end_date);
        paramIndex += 2;
      }
      
      const whereClause = `WHERE ${whereConditions.join(' AND ')}`;
      
      // Count total
      const countQuery = `SELECT COUNT(*) FROM order_dispatch ${whereClause}`;
      const countResult = await db.query(countQuery, queryParams);
      const total = parseInt(countResult.rows[0].count);
      
      // Get data
      const dataQuery = `
        SELECT * FROM order_dispatch 
        ${whereClause}
        ORDER BY actual_1 DESC, order_no ASC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;
      
      const dataResult = await db.query(dataQuery, [...queryParams, limit, offset]);
      
      return {
        success: true,
        data: dataResult.rows,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      Logger.error('Error fetching pre-approval history', error);
      throw new Error('Failed to fetch pre-approval history');
    }
  }

  /**
   * Submit pre-approval (set actual_1 to current timestamp)
   * @param {number} id - Order ID
   * @param {Object} data - Optional additional data to update
   * @returns {Promise<Object>} Updated order
   */
  async submitPreApproval(id, data = {}) {
    try {
      const updateData = {
        actual_1: new Date().toISOString(),
        ...data
      };
      
      const fields = Object.keys(updateData);
      const values = Object.values(updateData);
      
      const setClause = fields.map((field, index) => `${field} = $${index + 1}`).join(', ');
      
      const query = `
        UPDATE order_dispatch 
        SET ${setClause}
        WHERE id = $${fields.length + 1}
        RETURNING *
      `;
      
      const result = await db.query(query, [...values, id]);
      
      if (result.rows.length === 0) {
        throw new Error('Order not found');
      }
      
      Logger.info(`Pre-approval submitted for order ID: ${id}`);
      
      return {
        success: true,
        message: 'Pre-approval submitted successfully',
        data: result.rows[0]
      };
    } catch (error) {
      Logger.error('Error submitting pre-approval', error);
      throw error;
    }
  }
}

module.exports = new OrderDispatchService();
